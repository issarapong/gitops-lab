# Part 6: Kustomize Configuration Management

Kustomize is a Kubernetes configuration management tool that lets you customize YAML configurations without templates. It's built into kubectl and widely used in GitOps workflows.

## What is Kustomize?

Kustomize features:

- **Template-free**: No templating language required
- **Declarative**: Pure YAML configuration
- **Composable**: Layer configurations for different environments
- **Built-in**: Integrated with kubectl
- **GitOps-friendly**: Works seamlessly with ArgoCD and Flux

## Core Concepts

### Base and Overlays

```text
├── base/
│   ├── deployment.yaml
│   ├── service.yaml
│   └── kustomization.yaml
└── overlays/
    ├── dev/
    │   └── kustomization.yaml
    ├── staging/
    │   └── kustomization.yaml
    └── prod/
        └── kustomization.yaml
```

### Kustomization File

The `kustomization.yaml` file defines what to customize:

```yaml
apiVersion: kustomize.config.k8s.io/v1beta1
kind: Kustomization

# Resources to include
resources:
- deployment.yaml
- service.yaml

# Common labels applied to all resources
commonLabels:
  app: sample-app
  version: v1.0.0

# Common annotations
commonAnnotations:
  managed-by: kustomize

# Namespace for all resources
namespace: default

# Name prefix/suffix
namePrefix: dev-
nameSuffix: -v1

# Image transformations
images:
- name: nginx
  newTag: "1.21"
```

## Setting Up a Kustomize Project

### Step 1: Create Base Configuration

Let's expand our sample application with a more comprehensive base:

```yaml
# base/deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: sample-app
  labels:
    app: sample-app
spec:
  replicas: 3
  selector:
    matchLabels:
      app: sample-app
  template:
    metadata:
      labels:
        app: sample-app
    spec:
      containers:
      - name: app
        image: nginx:1.21
        ports:
        - containerPort: 80
        env:
        - name: ENVIRONMENT
          value: "default"
        resources:
          requests:
            memory: "64Mi"
            cpu: "250m"
          limits:
            memory: "128Mi"
            cpu: "500m"
        livenessProbe:
          httpGet:
            path: /
            port: 80
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /
            port: 80
          initialDelaySeconds: 5
          periodSeconds: 5
```

```yaml
# base/service.yaml
apiVersion: v1
kind: Service
metadata:
  name: sample-app-service
  labels:
    app: sample-app
spec:
  type: ClusterIP
  ports:
  - port: 80
    targetPort: 80
    protocol: TCP
    name: http
  selector:
    app: sample-app
```

```yaml
# base/configmap.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: sample-app-config
  labels:
    app: sample-app
data:
  app.properties: |
    # Application configuration
    app.name=Sample App
    app.version=1.0.0
    log.level=INFO
  nginx.conf: |
    server {
        listen 80;
        server_name localhost;
        
        location / {
            root /usr/share/nginx/html;
            index index.html index.htm;
        }
        
        location /health {
            access_log off;
            return 200 "healthy\n";
            add_header Content-Type text/plain;
        }
    }
```

```yaml
# base/kustomization.yaml
apiVersion: kustomize.config.k8s.io/v1beta1
kind: Kustomization

resources:
- deployment.yaml
- service.yaml
- configmap.yaml

commonLabels:
  app: sample-app
  managed-by: kustomize

# Generate ConfigMap from files
configMapGenerator:
- name: sample-app-config
  files:
  - configs/app.properties
  - configs/nginx.conf
```

### Step 2: Create Development Overlay

```yaml
# overlays/dev/kustomization.yaml
apiVersion: kustomize.config.k8s.io/v1beta1
kind: Kustomization

namespace: dev
namePrefix: dev-

resources:
- ../../base

commonLabels:
  environment: dev

# Patch the deployment
patchesStrategicMerge:
- deployment-patch.yaml

# JSON patches
patches:
- target:
    kind: Deployment
    name: sample-app
  patch: |-
    - op: replace
      path: /spec/replicas
      value: 1
    - op: replace
      path: /spec/template/spec/containers/0/env/0/value
      value: "development"

# ConfigMap generator override
configMapGenerator:
- name: sample-app-config
  behavior: merge
  literals:
  - "log.level=DEBUG"
  - "debug.enabled=true"

# Image overrides
images:
- name: nginx
  newTag: "alpine"
```

```yaml
# overlays/dev/deployment-patch.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: sample-app
spec:
  template:
    spec:
      containers:
      - name: app
        resources:
          requests:
            memory: "32Mi"
            cpu: "100m"
          limits:
            memory: "64Mi"
            cpu: "200m"
```

### Step 3: Create Staging Overlay

```yaml
# overlays/staging/kustomization.yaml
apiVersion: kustomize.config.k8s.io/v1beta1
kind: Kustomization

namespace: staging
namePrefix: staging-

resources:
- ../../base

commonLabels:
  environment: staging

replicas:
- name: sample-app
  count: 2

patches:
- target:
    kind: Deployment
    name: sample-app
  patch: |-
    - op: replace
      path: /spec/template/spec/containers/0/env/0/value
      value: "staging"

configMapGenerator:
- name: sample-app-config
  behavior: merge
  literals:
  - "log.level=WARN"
  - "cache.enabled=true"

images:
- name: nginx
  newTag: "1.21-alpine"
```

### Step 4: Create Production Overlay

```yaml
# overlays/prod/kustomization.yaml
apiVersion: kustomize.config.k8s.io/v1beta1
kind: Kustomization

namespace: production
namePrefix: prod-

resources:
- ../../base
- hpa.yaml
- ingress.yaml

commonLabels:
  environment: production

replicas:
- name: sample-app
  count: 5

patches:
- target:
    kind: Deployment
    name: sample-app
  patch: |-
    - op: replace
      path: /spec/template/spec/containers/0/env/0/value
      value: "production"
    - op: add
      path: /spec/template/spec/containers/0/env/-
      value:
        name: PRODUCTION_MODE
        value: "true"

configMapGenerator:
- name: sample-app-config
  behavior: merge
  literals:
  - "log.level=ERROR"
  - "cache.enabled=true"
  - "monitoring.enabled=true"

images:
- name: nginx
  newTag: "1.21"

# Production-specific resources
patchesStrategicMerge:
- service-loadbalancer.yaml
```

Let me create these files:

<function_calls>
<invoke name="create_file">
<parameter name="content">apiVersion: apps/v1
kind: Deployment
metadata:
  name: sample-app
  labels:
    app: sample-app
spec:
  replicas: 3
  selector:
    matchLabels:
      app: sample-app
  template:
    metadata:
      labels:
        app: sample-app
    spec:
      containers:
      - name: app
        image: nginx:1.21
        ports:
        - containerPort: 80
        env:
        - name: ENVIRONMENT
          value: "default"
        resources:
          requests:
            memory: "64Mi"
            cpu: "250m"
          limits:
            memory: "128Mi"
            cpu: "500m"
        livenessProbe:
          httpGet:
            path: /
            port: 80
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /
            port: 80
          initialDelaySeconds: 5
          periodSeconds: 5
